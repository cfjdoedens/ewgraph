# ewgraph

The goal of ewgraph is to represent and manipulate chance graphs as a
finite grid of data elements. The individual elements are called
segments. The grid is formed as a tibble. Each segment is a row of the
tibble.

The package design is not based on information hiding: the idea is that
users can know the details of how the chance graph is represented. And
possibly use this knowledge in unforeseen ways.

## Installation

You can install the development version of ewgraph from
[GitHub](https://github.com/) with:

``` r
  if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools")
  }
  devtools::install_github("cfjdoedens/ewgraph")
```

## Example

This is a basic example which shows you how to solve a common problem:

``` r
library(ewgraph)
# Construct an ewgraph of 1000 segments, resulting from a binomial draw of 300 samples,
# with ten errors found.
g <- ew_from_vec(dbinom(x = 10, size = 300, partition_0_1(1000)))

# Get most probable value for the error fraction, p, and accompanying 
# probability density, h.
most_prob_ph <- ew_maxh(g)
print(most_prob_ph)
#>        h        p 
#> 38.29659  0.03350

# Get maximum value for the error fraction, p, given
# certainty level cert.
max_error_rate <- ew_maxcumh_p(g, .95)
print(max_error_rate)
#> [1] 0.05571198
```

## equal width probability graphs

### Introduction

An equal width probability graph, ewgraph, is a finite numeric
representation of a function c from domain P to codomain H.
$$\left. c:P\rightarrow H \right.$$$P$ are the real numbers in
$\lbrack 0,1\rbrack$. $H$ are the real numbers in
$\lbrack 0,inf\rbrack$. $c$ is interpreted in this context as a function
that maps from an error fraction $p$ to the chance density of that error
fraction. $$h = c(p)$$ So $c$ is an absolutely continuous probability
distribution. And $c$ is a probability density function.

This function, $c$, is represented in an ewgraph as a finite set of $S$
pairs $\left( p_{i},h_{i} \right)$, $i$ in $1:S$. $S$ a positive
integer. $p_{i}$ are elements of P, so of \[0, 1\]. $h_{i}$ are elements
of H, so of \[0, inf\]. $$h_{i} = c\left( p_{i} \right)$$

Let $$U = 1/(2*S)$$ We define the ith segment of $P$ as
$\lbrack i/S - 1/S,i/S\rbrack$. So all segments have equal width,
$1/S = 2*U$. And there are $S$ segments. The middle of the ith segment
being $$p_{i} = i/(S - U)$$ So the segments are:
$$\lbrack 0,1/S\rbrack,\lbrack 1/S,2/S\rbrack,...,\left\lbrack (S - 1)/S,1 \right\rbrack$$

### The surface of a segment

An important aspect of a segment is its surface. For a probability
density function, the probability that an outcome lies on a certain
segment of P is proportional to the surface of that segment. We
approximate the surface of the probability function as the surfaces of
the segments of the corresponding equal width probability graph. The sum
of the surfaces of all segments is by definition 1.

As a first approximation we can equal the surface of a segment to
$h_{i}*(1/S)$. See drawing below of segment i

``` r
#                  |hi
#                  |
#                  |
#                  |
#                  |
#   _______________|________________
#   pi - U         pi               pi + U
#   =              =                =
#   i/S - 2U       i/S - U          i/S
```

$$surface_{i} = length.of.segment*height.of.segment$$$$= \left( p_{i} + U - \left( p_{i} - U \right) \right))*h_{i}$$$$= 2U*h_{i}$$$$= (1/S)*h_{i}$$

When the probability graph is rather flat this is a nice approximation.
However on steep parts of the graph, the approximation is less a good
fit. To improve on this we approximate the surface of a segment by
computing also the height of the begin and end points of the segment. So
by computing $h_{p_{i - U}} \equiv hleft_{i}$, and
$h_{p_{i + U}} \equiv hright_{i}$. We can then compute the surface of
segment $i$ as the sum of its left and right parts.

``` r
#                  |hi
#                  |
#                  |               |hrighti
#  |hlefti         |               |
#  |               |               |
#  |_______________|_______________|
#  pi - U          pi              pi + U
#   =              =                 =
# i/S - 2U        i/S - U            i/S
```

$$surface_{i} = surface.left_{i} + surface.right_{i}$$$$surface.left_{i} = length.of.left.halve.of.segment_{i}*\left( hleft_{i} + h_{i} \right)/2$$$$= U*\left( hleft_{i} + h_{i} \right)/2$$$$surface.right_{i} = length.of.right.halve.of.segment_{i}*\left( h_{i} + hright_{i} \right)/2$$$$= U*\left( h_{i} + hright_{i} \right)/2$$$$surface_{i} = U*\left( hleft_{i} + h_{i} \right)/2 + U*\left( h_{i} + hright_{i} \right)/2$$$$= \left( hleft_{i} + hright_{i} + 2*h_{i} \right)*U/2$$

We compute $hleft_{i}$ and $hright_{i}$ by interpolation.

For $hleft_{i}$ we proceed: Let $$h_{im1} = c\left( p_{im1} \right)$$
where $im1$ stands for $i - 1$. We then interpolate:
$$hleft_{i} = \left( h_{i} + h_{im1} \right)/2$$

``` r
#                                                  |hi
#                                  |hlefti         |
#                  |him1           |               |
#                  |               |               |
#   _______________|_______________|_______________|_______________
#                  pim1            pi - U          pi
#  segment i-1                     segment i
```

In the same vein we get
$$hright_{i} = \left( h_{i} + h_{ip1} \right)/2$$

``` r
#                  |hi
#                  |               |hrighti
#                  | hi            |               |hip1
#                  |               |               |
#   _______________|_______________|_______________|_______________
#                  pi              pim1 - U        pi
#  segment i                       segment i+1
```

This leaves us with the problem how to interpolate the leftmost
$hleft_{i}$, so $hleft_{1}$, and the rightmost $hright_{i}$, so
$hright_{S}$. This because, we can not interpolate with h_i from segment
0 or from segment $S + 1$, as these segments do not exist. For those
cases instead of interpolating we extrapolate.

For $hleft_{1}$:

``` r
#                                                 |h2
#                                 |               |
#                 |h1             |               |
#   |hleft1       |               |               |
#   |_____________|_______________|_______________|_______________
#   0             p1              p2 - U          p2
#   segment 1                     segment 2
```

The line through the coordinates $\left( U,h_{1} \right)$ and
$\left( 3*U,h_{2} \right)$ has the algebraic form $y = ax + b$. So
$$h_{1} = a*U + b$$$$h_{2} = a*3*U + b$$ Then we get
$$a = \left( h_{2} - h_{1} \right)/(2*U)$$$$b = \left( 3*h_{1} - h_{2} \right)/2$$
So for $hleft_{1}$ we get
$$hleft_{1} = a*0 + b$$$$= b$$$$= \left( 3*h_{1} - h_{2} \right)/2$$
However, note that $hleft_{1}$ could become less than 0. This we should
forbid, as it would imply a negative probability density.

So, taking this into account we get:
$$hleft_{1} = max\left( 0,\left( 3*h_{1} - h_{2} \right)/2 \right)$$

For $hright_{S}$:

``` r
#                 |hSm1
#                 |               |
#                 | h1            |               |hS
#                 |               |               |              |hrightS
#    _____________|_______________|_______________|______________|
#                 pSm1            pS - U          pS             1
#    segment S-1                  segment S
```

The line through the coordinates $\left( 1 - 3*U,h_{Sm1} \right)$ and
$\left( 1 - U,h_{S} \right)$ has the algebraic form $$y = ax + b$$ So
$$h_{Sm1} = a*(1 - 3*U) + b$$$$h_{S} = a*(1 - U) + b$$ Then we get
$$a = \left( h_{S} - h_{Sm1} \right)/(2*U)$$$$b = h_{S} + \left( h_{Sm1} - h_{S} \right)*(1 - U)/(2*U)$$

So for $hright_{S}$ we get
$$hright_{S} = a*1 + b$$$$= a + b$$$$= \left( h_{S} - h_{Sm1} \right)/(2*U) + h_{S} + \left( h_{Sm1} - h_{S} \right)*(1 - U)/(2*U)$$$$= \left( 3*h_{S} - h_{Sm1} \right)/2$$
This outcome is symmetric with
$$hleft_{1} = \left( 3*h_{1} - h_{2} \right)/2$$

As with $hleft_{1}$ we should forbid negative values for $hright_{S}$.
So, taking this into account we get:
$$hright_{S} = max\left( 0,\left( 3*h_{S} - h_{Sm1} \right)/2 \right)$$

### Representation of a segment from an ewgraph as a geometric figure

See the figure below. A segment of an ewgraph ABDEF can be considered to
consist of two rectangular trapeziums, ABCF and EDCF, representing
respectively the left and right halve of the segment. The corners ABC
and CDE are rectangular.

The two trapeziums have a shared parallel line, CF, which has length hi.
The three (one from the left trapezium, AB, one shared, CF, and one from
the right trapezium, DE) parallel lines are perpendicular to the p-axis,
BD. The lines of each trapezium BC and DC, that lie on the p-axis have
each length U. Line AB has length $hleft_{i}$. Line ED has length
$hright_{i}$.

``` r
#                  F
#                  "
#                 / \
#                / | \
#               /  |  \
#              /   |   \
#             /    |    \
#            /     |     \
#           /      |      \
#          /       |       \
#         /        |        \
#        /         |         \
#       /          |          \
#      /           |           \
#     /            |            \
#    /             |             \
#   /              |              \
#A |               |               \
#  |               |                \ E
#  |               |                |
#  |               |                |
#  |               |                |
#  |_______________|________________|
#  B               C                D
#
#  Figure: depiction of a segment from an ewgraph.
```

### Comparison with standard numerical approximation of an integral

I cite from Wikipedia:

> In calculus, the definite integral of an arbitrary function f(x) can
> be numerically approximated as a discrete sum by partitioning the
> interval of integration into small uniform intervals and approximating
> the functionâ€™s value on each interval as the average of the values at
> its endpoints.

We see here the correspondence between the small uniform intervals used
for calculating the definite integral and the segments of the ewgraph.

In contrast to the cited method an ewgraph is in essence based on the
middle value of a segment. The reason for this choice is that typically
a probability graph in the realm we are dealing with, might have an
infinite height at $p = 0$ or at $p = 1$. By steering clear from these
values, we avoid this problem. Furthermore I think that using the one
middle value of a segment as representative is more elegant and more
symmetric than using the values of the end points as representative. But
this is also a matter of taste.

### Representation of ewgraph as R tibble

In the programming language R we represent the ewgraph as a tibble with
S rows. Each ith segment of the ewgraph has the following variables:

- `p[[i]] = i/S - U`, this means that `p[[i]]` is the mid point of the
  ith segment
- `h[[i]] = c(p[[i]])` so `h[[i]]` is the chance of `p[[i]]`
- `h_left[[i]]` which is a linear interpolation of `h[[i]]` and
  `h[[i-1]]` (but a linear extrapolation of `h[[1]]` and `h[[2]]` for
  `h_left[[1]]`)
- `h_right[[i]]` which is a linear interpolation of `h[[i]]` and
  `h[[i+1]]` (but a linear extrapolation of `h[[S]]` and `h[[S-1]]` for
  `h_right(S)`)
- `surface[[i]]` which is the surface of this ith segment.
- `cumsurface[[i]]` which is the cumulative of `surface[[i]]`, going
  from 1 to i

# Package index

## All functions

- [`density_over_0_1()`](https://cfjdoedens.github.io/ewgraph/reference/density_over_0_1.md)
  :

  Create vector of densities over `[0, 1]`

- [`ew_S()`](https://cfjdoedens.github.io/ewgraph/reference/ew_S.md) :
  Get the number of segments, i.e. number of rows, of an equal width
  graph.

- [`ew_add_h_leftright()`](https://cfjdoedens.github.io/ewgraph/reference/ew_add_h_leftright.md)
  : Add left and right interpolated and extrapolated heights to segments
  of equal width graph.

- [`ew_add_surface()`](https://cfjdoedens.github.io/ewgraph/reference/ew_add_surface.md)
  : Add surface and cumulative surface to segments of equal width graph.

- [`ew_d()`](https://cfjdoedens.github.io/ewgraph/reference/ew_d.md) :
  Probability density function for ew_graph

- [`ew_from_vec()`](https://cfjdoedens.github.io/ewgraph/reference/ew_from_vec.md)
  :

  Create an equal width probability graph from vector `v`

- [`ew_get_cumsurface()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_cumsurface.md)
  : Get the cumulative surface column of an equal width graph.

- [`ew_get_h()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_h.md)
  : Get the h column of an equal width graph.

- [`ew_get_h_left()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_h_left.md)
  : Get the h_left column of an equal width graph.

- [`ew_get_h_right()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_h_right.md)
  : Get the h_right column of an equal width graph.

- [`ew_get_p()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_p.md)
  : Get the p column of an equal width graph.

- [`ew_get_surface()`](https://cfjdoedens.github.io/ewgraph/reference/ew_get_surface.md)
  : Get the surface column of an equal width graph.

- [`ew_halfsegment_cumh_p()`](https://cfjdoedens.github.io/ewgraph/reference/ew_halfsegment_cumh_p.md)
  : In ew half segment, given cumulative value for h, find corresponding
  p value

- [`ew_high_density_interval()`](https://cfjdoedens.github.io/ewgraph/reference/ew_high_density_interval.md)
  : highest part of the graph with a given cumulative chance density

- [`ew_maxcumh_p()`](https://cfjdoedens.github.io/ewgraph/reference/ew_maxcumh_p.md)
  : maximum error rate for given certainty

- [`ew_maxh()`](https://cfjdoedens.github.io/ewgraph/reference/ew_maxh.md)
  : Return the (possibly interpolated) highest value of h, h_left, or
  h_right and corresponding error rate, p.

- [`ew_middle_peaked()`](https://cfjdoedens.github.io/ewgraph/reference/ew_middle_peaked.md)
  : Return TRUE iff the highest value of h is reached neither for the
  h_left of the first segment nor for the h_right of the last segment

- [`ew_mincumh_p()`](https://cfjdoedens.github.io/ewgraph/reference/ew_mincumh_p.md)
  : minimum error rate for given certainty

- [`ew_round_prob()`](https://cfjdoedens.github.io/ewgraph/reference/ew_round_prob.md)
  : Round probability value in accordance with number of segments of
  equal width graph

- [`ew_validate()`](https://cfjdoedens.github.io/ewgraph/reference/ew_validate.md)
  : Check whether object is a valid equal width graph

- [`find_non_monotone_pairs()`](https://cfjdoedens.github.io/ewgraph/reference/find_non_monotone_pairs.md)
  : Find input and output pairs of a function that are not monotone
  rising.

- [`is_monotone_rising()`](https://cfjdoedens.github.io/ewgraph/reference/is_monotone_rising.md)
  : Checks if a function is monotone rising over a specified interval.

- [`nonnegint()`](https://cfjdoedens.github.io/ewgraph/reference/nonnegint.md)
  : Check whether object is vector of non negative integers

- [`partition()`](https://cfjdoedens.github.io/ewgraph/reference/partition.md)
  : Partition line piece on the real line into equally sized consecutive
  segments

- [`partition_0_1()`](https://cfjdoedens.github.io/ewgraph/reference/partition_0_1.md)
  :

  Partition `[0, 1]` into equally sized consecutive segments

- [`posint()`](https://cfjdoedens.github.io/ewgraph/reference/posint.md)
  : Check whether object is vector of positive integers

- [`unity()`](https://cfjdoedens.github.io/ewgraph/reference/unity.md) :
  One argument constant function that returns 1

